[
  {
    "objectID": "breast_cancer.html",
    "href": "breast_cancer.html",
    "title": "Breast Cancer Analysis",
    "section": "",
    "text": "This analysis aims at predicting whether checkpoint inhibition therapy should be administered to a breast cancer patient based on their genetic expression profile."
  },
  {
    "objectID": "breast_cancer.html#data-preparation",
    "href": "breast_cancer.html#data-preparation",
    "title": "Breast Cancer Analysis",
    "section": "Data Preparation",
    "text": "Data Preparation\nThe necessary libraries are imported to set up the environment.\n\n# Import libraries\nlibrary(SingleCellExperiment)\nlibrary(scran)\nlibrary(scater)\nlibrary(PCAtools)\nlibrary(patchwork)\nlibrary(bluster)\n\nThe expression table and the location metadata are read in.\n\n# Read assay\nexpression_data &lt;- read.csv(\"data/assay.csv\", row.names = 1) |&gt;\n  as.matrix() |&gt;\n  t()\n\n# Read colData\nlocation_data &lt;- read.csv(\"data/location.csv\", row.names = 1)\n\nA SingleCellExperiment object is constructed from the assay and its corresponding colData.\n\n# Build SCE object\nsce &lt;- SingleCellExperiment(assay = list(counts = expression_data),\n                            colData = location_data)\n\nsce\n\nclass: SingleCellExperiment \ndim: 297 2748 \nmetadata(0):\nassays(1): counts\nrownames(297): ACTA2 ACTG2 ... ZEB1 ZNF571\nrowData names(0):\ncolnames(2748): 1 2 ... 2747 2748\ncolData names(2): X Y\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n\n\nThe experiment includes 2748 cells which express 297 genes."
  },
  {
    "objectID": "breast_cancer.html#normalisation",
    "href": "breast_cancer.html#normalisation",
    "title": "Breast Cancer Analysis",
    "section": "Normalisation",
    "text": "Normalisation\nThe counts assay is normalised with the log-norm transformation to make cells comparable and focus on logarithmic changes in expression.\n\nset.seed(100)\n\n# Normalise by cluster library size\nclust &lt;- quickCluster(sce)\nsce &lt;- computeSumFactors(sce, cluster = clust, min.mean = 0.1)\n\n# Scale and log transform counts\nsce &lt;- logNormCounts(sce)"
  },
  {
    "objectID": "breast_cancer.html#feature-selection",
    "href": "breast_cancer.html#feature-selection",
    "title": "Breast Cancer Analysis",
    "section": "Feature Selection",
    "text": "Feature Selection\nCells are modelled by their variability to determine whether a few Highly Variable Genes (HVGs) could be selected to represent cells.\n\n# Model gene variation\ndec &lt;- modelGeneVar(sce)\nfit &lt;- metadata(dec)\n\nThere are a few genes that show much greater variability than others (Figure 1). In particular, genes above the red line provide a certain extent of biological variance after excluding technical variance (red line). However, we decided to keep all of them in further analyses due to the relatively small size of the experiment, which might have been pre-filtered.\n\n# Visualise model fit to gene variation\nplot(fit$mean, fit$var,\n     xlab = \"Mean log Expression\",\n     ylab = \"Variance of log Expression\")\n\ncurve(fit$trend(x), col = \"red\", add = TRUE, lwd = 2)\n\n\n\n\nFigure 1: Model of the variance for each gene in terms of its log-expression profile. Every dot is a gene and the red line represents the baseline technical component.\n\n\n\n\nGenes are sorted by their variability to explore which genes might be used later to annotate clusters to the correct cell types. The first two, IGHG1 and IGHG4 represent B cell marker genes.\n\n# Order genes by variability\nhvg &lt;- getTopHVGs(dec)\nhvg\n\n  [1] \"IGHG1\"    \"IGHG4\"    \"FAT1\"     \"IGKC\"     \"FGFR4\"    \"LST1\"    \n  [7] \"HIF1A\"    \"MAPK3\"    \"TFRC\"     \"FN1\"      \"PTTG1\"    \"S100A8\"  \n [13] \"SULF1\"    \"CDKN2A\"   \"FCN1\"     \"KRT19\"    \"HSPG2\"    \"TFF1\"    \n [19] \"CD69\"     \"NOTCH1\"   \"CD24\"     \"PECAM1\"   \"KIF23\"    \"ACTA2\"   \n [25] \"COL1A2\"   \"MLPH\"     \"C1QA\"     \"CCNB1\"    \"FOXP3\"    \"IGHM\"    \n [31] \"FABP7\"    \"CD3G\"     \"GRB7\"     \"ICOS\"     \"COL3A1\"   \"NDC80\"   \n [37] \"PTPRC\"    \"TRAC\"     \"CD68\"     \"ACTG2\"    \"FAP\"      \"MYO10\"   \n [43] \"SDC1\"     \"CAPN13\"   \"TTC6\"     \"CD14\"     \"CDK6\"     \"HLA.DRB1\"\n [49] \"S100A4\"   \"THY1\"     \"GNG11\"    \"PLVAP\"    \"LTF\"      \"SKAP1\"   \n [55] \"LILRB1\"   \"FCRL5\"    \"CD19\"     \"ZNF571\"   \"IL2RA\"    \"ISG20\"   \n [61] \"COL1A1\"   \"ANLN\"     \"SPP1\"     \"KRT17\"    \"CD79B\"    \"TFF2\"    \n [67] \"CD38\"     \"IL7R\"     \"ADGRL4\"   \"TPM2\"     \"PGR\"      \"CCNE1\"   \n [73] \"APOC1\"    \"ICAM1\"    \"EIF3E\"    \"LGALS2\"   \"CD79A\"    \"CTSL\"    \n [79] \"FTL\"      \"COL4A2\"   \"CD5\"      \"ITGA6\"    \"CSRP2\"    \"GZMB\"    \n [85] \"CD3E\"     \"CD163\"    \"NKG7\"     \"LRP2\"     \"STAT5A\"   \"SLC39A6\" \n [91] \"COBL\"     \"CCL3\"     \"TYMS\"     \"LGMN\"     \"CD2\"      \"CCNE2\"   \n [97] \"MZB1\"     \"JUNB\"     \"NUF2\"     \"AHR\"      \"ERBB3\"    \"HLA.DRB5\"\n[103] \"MYB\"      \"FOXC1\"    \"BGN\"      \"HLA.DPA1\" \"NR3C1\"    \"IL3RA\"   \n[109] \"LAG3\"     \"BANK1\"    \"CD96\"     \"TBX21\"    \"MSR1\"     \"APOE\"    \n[115] \"PLEK\"     \"CEACAM1\"  \"SPDEF\"    \"CD4\"      \"CENPF\"    \"RAMP2\"   \n[121] \"CALCRL\"   \"CCL4\"     \"ALDH1A3\"  \"LUM\"      \"VIM\"      \"MELK\"    \n[127] \"CD3D\"     \"UBE2T\""
  },
  {
    "objectID": "breast_cancer.html#dimensionality-reduction",
    "href": "breast_cancer.html#dimensionality-reduction",
    "title": "Breast Cancer Analysis",
    "section": "Dimensionality Reduction",
    "text": "Dimensionality Reduction\nCurrently, cells are characterised by a large number of dimensions (297 genes). To select highly explanatory features and reduce noise, we perform Principal Component Analysis (PCA) on the assay.\n\n# Perform PCA\nsce &lt;- runPCA(sce,\n              assay.type = \"logcounts\",\n              ncomp = 20)\n\n# Retrieve percent explained variance\npca.vars &lt;- attr(reducedDim(sce, \"PCA\"), \"percentVar\")\n\n# Find elbow\nchosen.elbow &lt;- findElbowPoint(pca.vars)\n\n# Find cumulative explained variance\npca.cum.vars &lt;- cumsum(pca.vars)\n\nThe number of PCs for further analyses was determined by the percentage of explained variance in relation to the number of PCs (Figure 2). The first 7 PCs seem sufficient based on the elbow rule, whereas the first 9 PCs can explain more than 40% of the variance based on cumulative explained variance. Therefore, we reasoned that the first 10 PCs would provide an acceptable tradeoff between dimensionality and explained variance.\n\npar(mfrow = c(1, 2))\n\n# Visualise elbow\nplot(pca.vars, xlab = \"PC\", ylab = \"Explained Variance (%)\")\nabline(v = chosen.elbow, col = \"red\", lty = 2)\n\n# Visualise cumulative explained variance\nplot(pca.cum.vars,\n     xlab = \"PC\",\n     ylab = \"Explained Variance (%)\",\n     ylim = c(0, 100))\n\nabline(h = 40, col=\"red\", lty = 2)\ngrid()\n\n\n\n\nFigure 2: Variance explained by PCs. On the left, individual variances explained by the first 20 PCs with the elbow marked by a vertical red dashed line. On the right, the cumulative variance explained by the first n PCs with a 40% threshold marked by a horizontal red dashed line.\n\n\n\n\nFor exploratory purposes, the most expressed gene in every cell was found. Cells whose most expressed gene was different from the top 5 genes across the entire assay were labelled as “Other”.\n\n# Find top expressed gene for every cell\nmax.idx &lt;- apply(assay(sce, \"logcounts\"), 2, which.max)\nmax.genes &lt;- rownames(sce)[max.idx]\n\n# Find top 5 expressed genes across assay\ntop.genes &lt;- names(sort(table(max.genes), decreasing = TRUE))[seq(5)]\nmax.genes[!(max.genes %in% top.genes)] &lt;- \"Other\"\n\n# Store top expressed gene\nsce$TopGene &lt;- max.genes\n\nThe performance of PCA was roughly assessed by visualising the cells in the first four PCs coloured by their most expressed gene (Figure 3). The first PC seems to encode most of the variance between IGHG1/IGHG4+ cells and other cells in terms of most expressed gene, whereas higher PCs might encode different information.\n\n# Visualise PCA\nplotReducedDim(sce, \"PCA\",\n               ncomp = 4,\n               colour_by = \"TopGene\")\n\n\n\n\nFigure 3: PCA plots with the first four PCs and cells coloured by their most expressed gene.\n\n\n\n\nThe first 10 PCs are fed to TSNE and UMAP to further identify groups of cells and their relative position.\n\nset.seed(100)\n\n# Perform TSNE on the first 10 PCs\nsce &lt;- runTSNE(sce, dimred = \"PCA\", n_dimred = 10)\n# Perform UMAP on the first 10 PCs\nsce &lt;- runUMAP(sce, dimred = \"PCA\", n_dimred = 10)\n\nBoth TSNE and UMAP could identify the IGHG1/IGHG4+ group of cells previously found in PCA (Figure 4). This is encoded by the second axis in TSNE and the first axis in UMAP, respectively. Compared to PCA, TSNE and UMAP provided a better separation between other groups of cells, such as the HIF1A+, LYZ and other cells.\n\n# Generate TSNE plot\ntsne &lt;- plotReducedDim(sce, \"TSNE\", colour_by = \"TopGene\")\n# Generate UMAP plot\numap &lt;- plotReducedDim(sce, \"UMAP\", colour_by=\"TopGene\")\n\n# Visualise TSNE and UMAP\ntsne + umap +\n  plot_layout(guides = \"collect\")\n\n\n\n\nFigure 4: Non-linear dimensionality reduction. On the left, a TSNE plot with a default perplexity of 30. On the right, a UMAP plot with default number of neighbours of 15 and minimum distance between embedded points of 0.01. Cells are coloured by their top expressed gene."
  },
  {
    "objectID": "breast_cancer.html#clustering",
    "href": "breast_cancer.html#clustering",
    "title": "Breast Cancer Analysis",
    "section": "Clustering",
    "text": "Clustering\n\nset.seed(100)\n\n# Cluster cells\nkclust &lt;- clusterCells(sce,\n                       use.dimred = \"PCA\",\n                       BLUSPARAM = TwoStepParam(first = KmeansParam(centers = 1000),\n                                                second = NNGraphParam(k = 10)),\n                       full = TRUE)\n\n# Store clustering results\nsce$Cluster &lt;- kclust$cluster\n\n# View cluster counts\ntab &lt;- table(sce$Cluster)\nknitr::kable(tab, col.names = c(\"Cluster\", \"Count\"))\n\n\n\n\nCluster\nCount\n\n\n\n\n1\n568\n\n\n2\n326\n\n\n3\n766\n\n\n4\n511\n\n\n5\n318\n\n\n6\n259\n\n\n\n\n\n\n# Visualise UMAP of clustered cells\nplotReducedDim(sce, \"UMAP\",\n               colour_by = \"Cluster\",\n               text_by = \"Cluster\")\n\n\n\n\nFigure 5: Clustering results. UMAP plot of cells coloured by their assigned clusters. Cells were clustered with a two-step approach (kmeans and graph-based) based on the first PCs."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Neurogenomics Projects",
    "section": "",
    "text": "Projects:\n\nProject 1\nProject 4"
  },
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "Neurogenomics Project 1",
    "section": "",
    "text": "This project was published on GitHub (https://riborings.github.io/neurogenomics/project1.html).\n\nPart 1\nNext-Generation Sequencing (NGS) entails several high-throughput techniques that generate a big amount of data. The main two approaches involve long-read sequencing with Nanopore technology and short-read sequencing with an Illumina machine. In the latter case, Polymerase Chain Reaction (PCR) is performed by the sequencer to amplify the library and quantify gene expression.\nIn the ideal situation, we would expect to have a doubling of each RNA strand in a linear fashion, so that each molecule is duplicated and the ratio between the expression levels of the different genes is maintained. However, this process introduces different types of errors due to factors such as the the composition of the sequence (for example high fraction of G or C) or the secondary structure, stochasticity and mutation that make it impossible to deduce the absolute gene expression, especially for low-copy genes.\nIn addition, the sequencing process involves breaking the mRNA sequence into several pieces because the machine cannot sequence a full-length genome. Thus, multiple variants may originate from the same sequence, so we may think there are several copies of the same gene, but in reality it is one broken copy. Therefore, we may infer a wrong expression level. Instead, sequencing data provides a compositional measure of gene expression, where every observation (or gene) is quantified in relation to the rest of the pool. Thus, it is essential to normalise reads from different samples when drawing between-sample comparisons.\n\n\nPart 2\nThe package with the data of interest is imported.\n\n# Import package\nlibrary(pasilla)\n\nRNA-Seq data from Drosophila melanogaster is loaded from the package.\n\n# Load data\npasCts &lt;- system.file(\"extdata\", \"pasilla_gene_counts.tsv\",\n                      package = \"pasilla\", mustWork = TRUE)\n\npasAnno &lt;- system.file(\"extdata\", \"pasilla_sample_annotation.csv\",\n                       package=\"pasilla\", mustWork = TRUE)\n\ncts &lt;- as.matrix(read.csv(pasCts, sep = \"\\t\", row.names = \"gene_id\"))\n\ncoldata &lt;- read.csv(pasAnno, row.names = 1)\ncoldata &lt;- coldata[ , c(\"condition\", \"type\")]\n\nrownames(coldata) &lt;- sub(\"fb\", \"\", rownames(coldata))\ncts &lt;- cts[, rownames(coldata)]\n\nThe matrix cts contains the gene expression data in terms of the number of reads for 14599 genes from 7 samples.\n\n# View head of counts assay\nhead(cts, 10)\n\n            treated1 treated2 treated3 untreated1 untreated2 untreated3\nFBgn0000003        0        0        1          0          0          0\nFBgn0000008      140       88       70         92        161         76\nFBgn0000014        4        0        0          5          1          0\nFBgn0000015        1        0        0          0          2          1\nFBgn0000017     6205     3072     3334       4664       8714       3564\nFBgn0000018      722      299      308        583        761        245\nFBgn0000022        0        0        0          0          1          0\nFBgn0000024       10        7        5         10         11          3\nFBgn0000028        0        1        1          0          1          0\nFBgn0000032     1698      696      757       1446       1713        615\n            untreated4\nFBgn0000003          0\nFBgn0000008         70\nFBgn0000014          0\nFBgn0000015          2\nFBgn0000017       3150\nFBgn0000018        310\nFBgn0000022          0\nFBgn0000024          3\nFBgn0000028          0\nFBgn0000032        672\n\n\nDimensions of the counts assay can be retrieved with the dim function.\n\n# Store assay dimensions\nmat_dim &lt;- dim(cts)\n# View assay dimensions\nmat_dim\n\n[1] 14599     7\n\n\nSamples differ from one another in the library size. Therefore, read counts should be normalised.\n\n# View raw library sizes\ncolSums(cts)\n\n  treated1   treated2   treated3 untreated1 untreated2 untreated3 untreated4 \n  18670279    9571826   10343856   13972512   21911438    8358426    9841335 \n\n\nNormalisation is performed by dividing the reads from every sample by the corresponding library size and multiplying by the library size of the first sample.\n\n# Normalise all samples to library size of first sample\nnorm_cts &lt;- apply(cts, 2, function(col) col / sum(col) * sum(cts[ , 1]))\n# Check normalised library sizes\ncolSums(norm_cts)\n\n  treated1   treated2   treated3 untreated1 untreated2 untreated3 untreated4 \n  18670279   18670279   18670279   18670279   18670279   18670279   18670279 \n\n\n\n\nPart 3\nA function to compute log means and variances for every feature in an assay is defined below, so that the same workflow can be applied both to untreated and treated samples.\n\n# Define function to compute feature-wise log means and vars\nfind_log_stats &lt;- function(assay, na.rm = FALSE, pseudocount = 1) {\n  \n  # Compute row means and vars\n  gene_means &lt;- rowMeans(assay, na.rm = na.rm)\n  gene_vars &lt;- rowVars(assay, na.rm = na.rm)\n\n  # Take log of means and vars with pseudocount\n  gene_log_means &lt;- log(gene_means + pseudocount)\n  gene_log_vars &lt;- log(gene_vars + pseudocount)\n\n  # Combine data into a data.frame\n  df &lt;- data.frame(Var = gene_log_vars, Mean = gene_log_means)\n  return(df)\n}\n\nThe log statistics of the genes from the untreated samples are computed.\n\n# Subset data to untreated samples\ncontrol_cts &lt;- norm_cts[ , grep(\"^untreated\", colnames(norm_cts))]\n# Find log means and vars for genes in control samples\ncontrol_stats &lt;- find_log_stats(control_cts)\n\nThe Poisson distribution fits the data relatively well for lower numbers of reads, but it creates bias for higher numbers of reads where the variance becomes larger than the mean. Such phenomenon is called overdispersion.\n\n# Visualise fit of Poisson distribution to data\nplot(control_stats$Mean, control_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\nabline(a = 0, b = 1, col = \"red\")\nlegend(\"topleft\", \"Poisson Fit\", lty = 1, col = \"red\")\n\n\n\n\nThe dispersion coefficient of the negative binomial distribution can be determined by fitting the corresponding mean-variance relationship to the data.\n\n# Fit dispersion coefficient of negative binomial distribution to data\nnls_fit &lt;- nls(Var ~ Mean + a * Mean^2, data = control_stats, start = list(a = 0))\nsummary(nls_fit)\n\n\nFormula: Var ~ Mean + a * Mean^2\n\nParameters:\n  Estimate Std. Error t value Pr(&gt;|t|)    \na 0.052201   0.000206   253.3   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.8978 on 14598 degrees of freedom\n\nNumber of iterations to convergence: 1 \nAchieved convergence tolerance: 1.408e-11\n\n\nUnlike the Poisson distribution, the negative binomial distribution fits well the data both for lower and higher numbers of reads.\n\n# Define var-mean relationship of negative binomial distribution\ndisper_coef &lt;- summary(nls_fit)$coefficients[\"a\", \"Estimate\"]\nneg_binom &lt;- function(x) x + disper_coef * x^2\n\n# Visualise fit of negative binomial distribution to data\nplot(control_stats$Mean, control_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\ncurve(neg_binom, col = \"red\", add = TRUE)\nlegend(\"topleft\", \"Negative Binomial Fit\", lty = 1, col = \"red\")\n\n\n\n\nThe same pipeline is applied to the genes from the treated samples.\n\n# Subset data to treated samples\ntreated_cts &lt;- norm_cts[ , grep(\"^treated\", colnames(norm_cts))]\n# Find log means and vars for genes in treated samples\ntreated_stats &lt;- find_log_stats(treated_cts)\n\n\n# Visualise fit of Poisson distribution to data\nplot(control_stats$Mean, treated_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\nabline(a = 0, b = 1, col = \"red\")\nlegend(\"topleft\", \"Poisson Fit\", lty = 1, col = \"red\")\n\n\n\n\n\n# Fit dispersion coefficient of negative binomial distribution to data\nnls_fit &lt;- nls(Var ~ Mean + a * Mean^2, data = treated_stats, start = list(a = 0))\nsummary(nls_fit)\n\n\nFormula: Var ~ Mean + a * Mean^2\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \na 0.0439520  0.0002798   157.1   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.227 on 14598 degrees of freedom\n\nNumber of iterations to convergence: 1 \nAchieved convergence tolerance: 7.173e-11\n\n\n\n# Define var-mean relationship of negative binomial distribution\ndisper_coef &lt;- summary(nls_fit)$coefficients[\"a\", \"Estimate\"]\nneg_binom &lt;- function(x) x + disper_coef * x^2\n\n# Visualise fit of negative binomial distribution to data\nplot(treated_stats$Mean, treated_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\ncurve(neg_binom, col = \"red\", add = TRUE)\nlegend(\"topleft\", \"Negative Binomial Fit\", lty = 1, col = \"red\")\n\n\n\n\nJudging by our results, we can estimate that the different untreated and treated samples in this experiment are biological repeats, because these changes are represented by a greater variability that corresponds to a negative binomial distribution and less to a Poisson distribution, this is due to the variability that exists between different animals/tissues. As we can see, our distribution also better fits a negative binomial distribution.\n\n\nPart 4\n\n# Transform normalised assay to log assay with pseudocount\nlog_cts &lt;- log(norm_cts + 1)\n\n\n# Visualise log counts of treated vs untreated samples\nplot(log_cts[ , \"untreated1\"], log_cts[ , \"treated1\"],\n     xlab = \"Log Expression (untreated)\", ylab = \"Log Expression (treated)\")\ngrid()\n\n\n\n\n\n# Identify gene that is expressed more in treated samples\ncontrol_cond &lt;- control_stats$Mean &gt; 8.5 & control_stats$Mean &lt; 9.5\ntreated_cond &lt;- treated_stats$Mean &gt; 10 & treated_stats$Mean &lt; 11\n\ngene1 &lt;- rownames(norm_cts)[control_cond & treated_cond]\ngene1\n\n[1] \"FBgn0033367\"\n\n\n\n# Identify gene that is expressed more in untreated samples\ncontrol_cond &lt;- control_stats$Mean &gt; 7 & control_stats$Mean &lt; 8\ntreated_cond &lt;- treated_stats$Mean &gt; 4 & treated_stats$Mean &lt; 5\n\ngene2 &lt;- rownames(norm_cts)[control_cond & treated_cond]\ngene2\n\n[1] \"FBgn0039155\"\n\n\nThe expression of FBgn0039155 shows consistent differences between the control and treated conditions.\n\n# Visualise differential expression of selected gene\nplot(log_cts[gene2, ], ylab = \"Log Expression\")\ntitle(gene2)\n\n\n\n\nOur data fit the basic assumptions of DEseq, as it based on negative binomial distribution.\n\nlibrary(DESeq2)\n\n\n# Run deseq2\ndds &lt;- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design = ~ condition)\n\ndds &lt;- DESeq(dds)\nres &lt;- results(dds)\n\nres\n\nlog2 fold change (MLE): condition untreated vs treated \nWald test p-value: condition untreated vs treated \nDataFrame with 14599 rows and 6 columns\n               baseMean log2FoldChange     lfcSE        stat    pvalue\n              &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt; &lt;numeric&gt;\nFBgn0000003    0.171569    -1.02604541  3.805503 -0.26962147 0.7874515\nFBgn0000008   95.144079    -0.00215142  0.223884 -0.00960955 0.9923328\nFBgn0000014    1.056572     0.49673557  2.160264  0.22994204 0.8181368\nFBgn0000015    0.846723     1.88276170  2.106432  0.89381546 0.3714206\nFBgn0000017 4352.592899     0.24002523  0.126024  1.90459450 0.0568328\n...                 ...            ...       ...         ...       ...\nFBgn0261571 8.73437e-02     -0.9002942  3.810165  -0.2362875  0.813210\nFBgn0261572 6.19714e+00      0.9591315  0.777017   1.2343759  0.217063\nFBgn0261573 2.24098e+03     -0.0126158  0.112701  -0.1119412  0.910870\nFBgn0261574 4.85774e+03     -0.0152569  0.193148  -0.0789905  0.937040\nFBgn0261575 1.06836e+01     -0.1635594  0.938909  -0.1742016  0.861707\n                 padj\n            &lt;numeric&gt;\nFBgn0000003        NA\nFBgn0000008  0.996927\nFBgn0000014        NA\nFBgn0000015        NA\nFBgn0000017  0.282361\n...               ...\nFBgn0261571        NA\nFBgn0261572        NA\nFBgn0261573  0.982035\nFBgn0261574  0.988143\nFBgn0261575  0.967912\n\n\nCuriously, FBgn0039155 was designated as the most differentially expressed gene by DESeq2 (effect size: 4.62, p-value: 4.07^{-161}), whereas FBgn0033367 did not appear among the top 10 genes but showed statistical significance (effect size: -1.45, p-value: 10^{-9}).\n\n# View genes ordered by differential expression\nsorted_res &lt;- res[order(res$padj), c(\"log2FoldChange\", \"padj\")]\nhead(sorted_res, 10)\n\nlog2 fold change (MLE): condition untreated vs treated \n \nDataFrame with 10 rows and 2 columns\n            log2FoldChange         padj\n                 &lt;numeric&gt;    &lt;numeric&gt;\nFBgn0039155        4.61901 4.06607e-161\nFBgn0025111       -2.89986 6.38334e-112\nFBgn0029167        2.19700 3.69146e-110\nFBgn0003360        3.17967 1.98854e-105\nFBgn0035085        2.56041  2.14348e-74\nFBgn0039827        4.16252  1.74302e-68\nFBgn0034736        3.51144  4.59386e-57\nFBgn0029896        2.44502  3.03284e-55\nFBgn0000071       -2.67958  8.79175e-46\nFBgn0051092       -2.32771  1.09010e-36\n\n\n\n\nPart 5\nThe circadian RNA-Seq data from Zebrafish is imported and processed into a matrix with unique rownames.\n\n# Import dataset\ncirc_df &lt;- read.csv(\"data/CircadianRNAseq.csv\")\n\n# Preprocess dataset\nrownames(circ_df) &lt;- make.unique(circ_df$GeneSymbol)\ncirc_df[ , c(\"RefSeqID\", \"GeneSymbol\")] &lt;- NULL\ncirc_mat &lt;- as.matrix(circ_df)\n\nThe last five rows (or genes) of the assay are printed below. From the colnames, it can be deduced that samples were collected from 11 PM until 7 PM for two consecutive days, with a time interval of 4 hours.\n\n# Show expression of last 5 genes\ntail(circ_mat, 5)\n\n              A_11PM     A_3AM     A_7AM    A_11AM     A_3PM     A_7PM\nzgc:136896 255.99900 209.97600 125.42200 143.07200 112.50300 101.81700\nLCP1         5.72658   6.62624   6.62286   9.62324   5.98339   5.37718\nRab3gap1.1  11.32120  14.44910  15.91110  11.89190  13.33890  12.65970\nACTR3       50.64750  56.36470  66.65160  85.98560  54.14030  59.21070\nUBXN4       13.65380  15.55590  23.63540  18.67810  18.75290  16.04330\n              B_11PM     B_3AM     B_7AM   B_11AM    B_3PM    B_7PM\nzgc:136896 201.12300 118.10400 255.72500 89.71120 92.12400 86.27090\nLCP1         3.90986   9.07169   6.51965  6.85435  5.85492  4.42235\nRab3gap1.1  10.15590  16.13480  13.85730 15.99760 15.21870 16.85700\nACTR3       53.61420  58.49680  51.49100 46.21930 50.31010 45.71560\nUBXN4       13.86520  20.21520  15.92240 19.05500 19.76430 19.02300\n\n\nThe expression of the per1a gene shows a rather consistent periodicity of 24 hours over the two days of sampling. Such observation agrees with the literature, as per1a is one of the genes responsible for the circadian rhythm of insects as well as mammals, where it is mostly expressed in the area of the brain known as suprachiasmatic nucleus (SPN).\n\n# Visualise oscillatory pattern of per1a gene over samples\nplot(circ_mat[\"per1a\", ], ylab = \"Norm Expression\", type = \"b\", xaxt = \"n\")\naxis(1, at = 1:12, labels = colnames(circ_mat)) \n\n\n\n\n\n# Find frequency powers\npowers &lt;- fft(circ_mat[\"per1a\", ])\npowers &lt;- as.numeric(powers * Conj(powers))[2:(1 + length(powers) / 2)]\nnorm_powers &lt;- powers / sum(powers)\n\n\n# Find base frequencies\nt &lt;- 4\nmin_freq &lt;- 1 / (ncol(circ_mat) * t)\nmax_freq &lt;- 1 / (2 * t)\n\nfreq_range &lt;- seq(from = min_freq, to = max_freq, by = min_freq)\n\n\n# Visualise frequency components of oscillatory pattern for per1a\nplot(freq_range, norm_powers, xlab = \"Frequency in 1/h\", ylab = \"Norm Power\")\n\n\n\n\nBetween the options of (a) designing an experiment with (a) a higher time resolution or (b) a longer duration, we believe that option (b) is preferred, because, as we learned and applied at the beginning of the exercise, in order to get more reliable results, there is first of all a need to perform repeated measurements of the same situation. Therefore, if we want to prove that a certain gene operates at a circadian frequency, we must first measure it a sufficient number of times in order to prove that it is not an error/noise/non-normalized results and more. In addition, in order to show that this is not a temporary or passing phenomenon, measurement of multiple days will make it possible to prove that the gene works in a circadian manner regularly. However, option (a) can yield a more accurate estimate of the frequency components of the signal and to increase the Nyquist frequency, so it can be useful in situations where we want to get the best shape of the signal expressing the expression level or get a wider range of frequencies along the way.\nFrequency analysis represents a more powerful tool than time analysis to detect the oscillatory nature of biological signals. Because signals are almost always composed by several waves with different sub-frequencies and mixed up with noise, it is not practical to study their oscillatory nature in the time domain. Instead, the frequency domain allows to separate the frequency components of the signal, which can be thereby described as the sum of simple waves, such as sine and cosine functions. In addition, working with frequencies you can take out noises and get better results for the circadian cycle.\n\n# Define function to obtain frequency powers with fft\ncompute_powers &lt;- function(time_series) {\n  \n  powers &lt;- fft(time_series)\n  powers &lt;- as.numeric(powers * Conj(powers))[2:(1 + length(powers) / 2)]\n  norm_powers &lt;- powers / sum(powers)\n  \n  return(norm_powers)\n}\n\n\n# Obtain frequency powers for every gene in assay\npower_mat &lt;- t(apply(circ_mat, 1, compute_powers))\n\n# Sort genes by their 24-hour frequency power\npower_idx &lt;- order(power_mat[ , 2], decreasing = TRUE)\nsorted_powers &lt;- rownames(power_mat)[power_idx]\n\n# sort provides an easier way\n# sorted_powers &lt;- sort(power_mat[ , 2], decreasing = TRUE)\n\nhead(sorted_powers, 10)\n\n [1] \"atxn1b\"    \"fus\"       \"nr1d2b\"    \"rdh1l\"     \"ankrd10a\"  \"phyhd1\"   \n [7] \"arntl1b.1\" \"ARNTL2\"    \"Ldhd\"      \"aclya\"    \n\n\nWe found out that one of the relevant genes - ‘nr1d2b’, is involved in regulation of circadian rhythm.\n\n# Check if na values are present\nsum(is.na(sorted_powers))\n\n[1] 0\n\n\n\n\nPart 6\n\n# Compute log statistics of each gene with custom function from part 3\ncirc_stats &lt;- find_log_stats(circ_mat, na.rm = TRUE)\n\nThe genes are binned by similarity in library size and a z-score is calculated within each bin. The top 40 genes with the highest z-score are then inspected to understand their relation with circadian rhythms.\n\nlibrary(dplyr)\nlibrary(tibble)\n\n# Bin genes and compute their z-score\nzscore_df &lt;- circ_stats %&gt;%\n  rownames_to_column(\"GeneSymbol\") %&gt;%\n  filter(Mean &gt;= 3) %&gt;%\n  mutate(Bin = ntile(Mean, 20)) %&gt;%\n  group_by(Bin) %&gt;%\n  mutate(ZScore = (Var - mean(Var)) / sd(Var)) %&gt;%\n  arrange(desc(ZScore))\n\n# View genes sorted by z-score\nknitr::kable(head(zscore_df, 40), digits = 2)\n\n\n\n\n\n\n\n\n\n\n\nGeneSymbol\nVar\nMean\nBin\nZScore\n\n\n\n\nCS.2\n9.77\n3.67\n11\n4.82\n\n\nLOC792433\n7.41\n3.09\n2\n4.45\n\n\nrho\n11.62\n4.90\n18\n3.75\n\n\nexorh.1\n16.50\n9.71\n20\n3.72\n\n\nzgc:136930\n7.83\n3.59\n10\n3.57\n\n\nzgc:194737\n6.13\n3.02\n1\n3.51\n\n\n.469\n6.77\n3.14\n3\n3.47\n\n\nsi:ch211-132b12.7.1\n8.09\n3.67\n11\n3.43\n\n\nzgc:92061.1\n7.97\n3.54\n9\n3.35\n\n\nzgc:103748\n6.88\n3.36\n7\n3.32\n\n\nolfm1b.1\n6.22\n3.26\n5\n3.25\n\n\nfabp7b\n7.76\n3.52\n9\n3.18\n\n\ncldna\n6.14\n3.22\n5\n3.17\n\n\nregulation of transcription, DNA-dependent .1\n5.77\n3.01\n1\n3.16\n\n\n.120\n8.30\n4.00\n14\n3.13\n\n\nnr1d2b.1\n7.30\n3.56\n10\n3.10\n\n\nbhlhb3l\n8.79\n4.06\n15\n3.09\n\n\n.161\n7.74\n3.82\n13\n3.06\n\n\naqp3a\n8.69\n4.19\n15\n3.01\n\n\nFOS\n6.62\n3.32\n6\n3.01\n\n\nscinlb\n6.55\n3.38\n7\n3.01\n\n\ncfdl\n7.66\n3.90\n13\n2.99\n\n\nCox7c\n8.77\n4.36\n16\n2.96\n\n\nCFL1\n8.08\n3.98\n14\n2.94\n\n\nzgc:162144\n7.07\n3.57\n10\n2.90\n\n\nCamk2n1\n5.84\n3.26\n5\n2.87\n\n\nCyp11b2\n5.94\n3.17\n4\n2.86\n\n\narg2\n5.90\n3.15\n4\n2.83\n\n\nicn2\n6.94\n3.61\n10\n2.79\n\n\nndrg1l\n9.38\n4.58\n17\n2.79\n\n\n.241\n5.65\n3.04\n2\n2.78\n\n\ncldnb\n6.78\n3.43\n8\n2.77\n\n\nUQCRQ\n7.08\n3.74\n12\n2.74\n\n\nper1b\n7.25\n3.66\n11\n2.74\n\n\nzgc:63920.1\n5.58\n3.05\n2\n2.72\n\n\nCry3\n5.91\n3.14\n3\n2.71\n\n\ngria2b\n6.26\n3.29\n6\n2.69\n\n\nflr.1\n5.65\n3.21\n5\n2.68\n\n\nsi:dkey-7c18.24\n8.27\n4.19\n15\n2.67\n\n\nLOC563601\n5.86\n3.12\n3\n2.66\n\n\n\n\n\nWe can detect some known circadian genes from this table: For example – the gene ‘nr1d2b’ is involved in regulation of circadian rhythm. In addition, the gene ‘bhlhb3l’ is involved in regulation of circadian rhythms. It Is expected that circadian genes will also be variable gene, as they are changing over time during the day, so it make sense that they have big differences in expression levels. Also, changes in environmental conditions throughout the day may lead to the need for the body to adapt to different conditions such as different weather during the day or night or light and darkness, therefore the ability to change in cycles over time can lead to increased variability in expression"
  },
  {
    "objectID": "breast_cancer.html#marker-gene-detection",
    "href": "breast_cancer.html#marker-gene-detection",
    "title": "Breast Cancer Analysis",
    "section": "Marker Gene Detection",
    "text": "Marker Gene Detection\n\n# Score marker genes by cluster\nmarker.info &lt;- scoreMarkers(sce, sce$Cluster)\n\n# Find top 5 marker genes for every cluster based on mean AUC score\nmarker.genes &lt;- lapply(\n  marker.info,\n  function(x) rownames(x)[order(x$mean.AUC, decreasing = TRUE)][seq(5)]\n)\n\n# View top 5 marker genes by cluster\nmarker.genes\n\n$`1`\n[1] \"IGHG1\" \"IGHG4\" \"FAT1\"  \"IGKC\"  \"FGFR4\"\n\n$`2`\n[1] \"FN1\"   \"HLA.B\" \"ACTA2\" \"KIF23\" \"GNG11\"\n\n$`3`\n[1] \"KRT19\" \"KRT18\" \"TFF1\"  \"MYL6\"  \"HSPB1\"\n\n$`4`\n[1] \"CD24\"   \"FOS\"    \"COL3A1\" \"LYZ\"    \"ZNF571\"\n\n$`5`\n[1] \"SULF1\" \"HIF1A\" \"FOXP3\" \"MLPH\"  \"APOE\" \n\n$`6`\n[1] \"TFRC\"  \"KRT19\" \"FASN\"  \"TFF1\"  \"KRT18\""
  },
  {
    "objectID": "breast_cancer.html#cell-type-annotation",
    "href": "breast_cancer.html#cell-type-annotation",
    "title": "Breast Cancer Analysis",
    "section": "Cell Type Annotation",
    "text": "Cell Type Annotation\n\n# Infer cell type manually\ncell.types &lt;- c(\"B cell\", \"Fibroblast\", \"Tumour Core\", \"Tumour Edge\", \"T cell\", \"Tumour Core\")\n# Store cell type\nsce$CellType &lt;- sapply(sce$Cluster, function(x) cell.types[x])\n\n\n# Generate UMAP plot\numap &lt;- plotReducedDim(sce, \"UMAP\", colour_by = \"CellType\", text_by = \"Cluster\")\n# Generate colData plot\nspatial &lt;- plotColData(sce, \"Y\", \"X\", colour_by = \"CellType\")\n\n# Visualise UMAP and colData plots\numap + spatial +\n  plot_layout(guides = \"collect\")\n\n\n\n\nFigure 6: Results of cell type annotation. On the left, a UMAP plot of the annotated cells coloured by their inferred cell type. Numbers represent the centre of each previously found cluster. On the right, cells in their original 2D space of the breast tissue.\n\n\n\n\nCluster 4 has cd24 but also lyz so it might be the battlefield where tumour and macrophages meet."
  },
  {
    "objectID": "breast_cancer.html#discussion",
    "href": "breast_cancer.html#discussion",
    "title": "Breast Cancer Analysis",
    "section": "Discussion",
    "text": "Discussion\n\nQuestion 1\nBased on our manual annotation, more than 30% of the assay consists of B or T cells. Thus, the percentage of immune cells likely surpasses 10% even if some margin of error is considered.\n\n# Compute percentage of cell types\ntab &lt;- table(sce$CellType) / ncol(sce) * 100\n\nknitr::kable(tab,\n             digits = 2,\n             col.names = c(\"Cell Type\", \"Abundance (%)\"))\n\n\n\n\nCell Type\nAbundance (%)\n\n\n\n\nB cell\n20.67\n\n\nFibroblast\n11.86\n\n\nT cell\n11.57\n\n\nTumour Core\n37.30\n\n\nTumour Edge\n18.60\n\n\n\n\n\n\n\nQuestion 2\nB and T cells appear to intermix with the tumour cells to a large extent. The spatial distribution illustrated by Fig Figure 6 suggests that immune cells attempt to infiltrate the small agglomerations formed by the tumour cells, which reflects a positive response of the immune system against the tumour.\n\n\nQuestion 3\nMore than 10% of the cells in the assay express at least 1 copy of the PD-L1 gene, which corresponds to a non-null log-count as computed below. Also within only T cells, at least 10% of them express the PD-L1 gene.\n\n# Compute percentage of PD-L1+ cells\ntab1 &lt;- table(assay(sce, \"logcounts\")[\"CD274\", ] != 0) / ncol(sce) * 100\n\n# Compute percentage of PD-L1+ T cells\nsce.tcell &lt;- sce[ , sce$CellType == \"T cell\"]\ntab2 &lt;- table(assay(sce.tcell, \"logcounts\")[\"CD274\", ] != 0) /\n  sum(ncol(sce.tcell)) * 100\n\n# Combine tables\ntab &lt;- rbind(tab1, tab2)\nrownames(tab) &lt;- c(\"All Cells\", \"T Cells\")\ncolnames(tab) &lt;- c(\"PD-L1-\", \"PD-L1+\")\n\n# View results\nknitr::kable(tab, digits = 2)\n\n\n\n\n\nPD-L1-\nPD-L1+\n\n\n\n\nAll Cells\n88.54\n11.46\n\n\nT Cells\n89.94\n10.06\n\n\n\n\n\nFigure 7 illustrates the distribution of PD-L1 expression across different cell types.\n\n# Visualise expression of PD-L1\nplotExpression(sce, features = \"CD274\", x = \"CellType\", colour_by = \"CellType\")\n\n\n\n\nFigure 7: Distribution of PD-L1 log-norm expression across all cells grouped and coloured by annotated cell type."
  },
  {
    "objectID": "breast_cancer.html#conclusion",
    "href": "breast_cancer.html#conclusion",
    "title": "Breast Cancer Analysis",
    "section": "Conclusion",
    "text": "Conclusion\nThe current study aimed to annotate cells from a tissue of breast cancer analysed with scRNA-seq in order to predict the patient’s response to checkpoint inhibitory therapy. Overall, the analyses provided all the indicators for a positive response: 1) immune cells make up about 30% of the tissue, 2) they are intermixed with the tumour and 3) about 10% of all cells (as well as T cells) express the PD-L1 gene. Taken altogether, the patient is expected to respond well to checkpoint inhibitory therapy."
  }
]