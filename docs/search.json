[
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "Project 1",
    "section": "",
    "text": "knitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n\nPart 1\nNext-Generation Sequencing (NGS) entails several high-throughput techniques that generate big amount of data. The main two approaches involve long-read sequencing with technology and short-read sequencing with an Illumina machine. In the latter case, Polymerase Chain Reaction (PCR) is performed by the sequence to amplify the library and quantify gene expression.\nIn the ideal situation, we would expect to have a doubling of each RNA strand in a linear fashion, so that each molecule is duplicated and the ratio between the expression levels of the different genes is maintained. However, this process introduces different types of errors due to factors such as the composition of the sequence (for example high fraction of G or C) or the secondary structure, stochasticity and mutation that make it impossible to deduce the absolute gene expression, especially for low-copy genes.\nIn addition, the sequencing process involves breaking the mRNA sequence into several pieces because the machine cannot sequence a full-length genome. Thus, multiple sequences may originate from the same sequence, so we may think there are several copies of the same gene, but in reality it is one broken copy. Therefore, we may infer a wrong expression level. Instead, sequencing data provides a compositional measure of gene expression, where every observation (or gene) is quantified in relation with the rest of the pool. Thus, it is essential to normalise reads from different samples when drawing between-sample comparisons.\n\n\nPart 2\nThe package with the data of interest is imported.\n\n# Import package\nlibrary(pasilla)\n\nRNA-Seq data from Drosophila melanogaster is loaded from the package.\n\n# Load data\npasCts &lt;- system.file(\"extdata\", \"pasilla_gene_counts.tsv\",\n                      package = \"pasilla\", mustWork = TRUE)\n\npasAnno &lt;- system.file(\"extdata\", \"pasilla_sample_annotation.csv\",\n                       package=\"pasilla\", mustWork = TRUE)\n\ncts &lt;- as.matrix(read.csv(pasCts, sep = \"\\t\", row.names = \"gene_id\"))\n\ncoldata &lt;- read.csv(pasAnno, row.names = 1)\ncoldata &lt;- coldata[ , c(\"condition\", \"type\")]\n\nrownames(coldata) &lt;- sub(\"fb\", \"\", rownames(coldata))\ncts &lt;- cts[, rownames(coldata)]\n\nThe matrix cts contains the gene expression data in terms of the number of reads for 14599 genes from 7 samples.\n\n# View head of counts assay\nhead(cts, 10)\n\n            treated1 treated2 treated3 untreated1 untreated2 untreated3\nFBgn0000003        0        0        1          0          0          0\nFBgn0000008      140       88       70         92        161         76\nFBgn0000014        4        0        0          5          1          0\nFBgn0000015        1        0        0          0          2          1\nFBgn0000017     6205     3072     3334       4664       8714       3564\nFBgn0000018      722      299      308        583        761        245\nFBgn0000022        0        0        0          0          1          0\nFBgn0000024       10        7        5         10         11          3\nFBgn0000028        0        1        1          0          1          0\nFBgn0000032     1698      696      757       1446       1713        615\n            untreated4\nFBgn0000003          0\nFBgn0000008         70\nFBgn0000014          0\nFBgn0000015          2\nFBgn0000017       3150\nFBgn0000018        310\nFBgn0000022          0\nFBgn0000024          3\nFBgn0000028          0\nFBgn0000032        672\n\n\nDimensions of the counts assay can be retrieved with the dim function.\n\n# Store assay dimensions\nmat_dim &lt;- dim(cts)\n# View assay dimensions\nmat_dim\n\n[1] 14599     7\n\n\nSamples differ from one another in the library size. Therefore, read counts should be normalised.\n\n# View raw library sizes\ncolSums(cts)\n\n  treated1   treated2   treated3 untreated1 untreated2 untreated3 untreated4 \n  18670279    9571826   10343856   13972512   21911438    8358426    9841335 \n\n\nNormalisation is performed by dividing the reads from every sample by the corresponding library size and multiplying by the library size of the first sample.\n\n# Normalise all samples to library size of first sample\nnorm_cts &lt;- apply(cts, 2, function(col) col / sum(col) * sum(cts[ , 1]))\n# Check normalised library sizes\ncolSums(norm_cts)\n\n  treated1   treated2   treated3 untreated1 untreated2 untreated3 untreated4 \n  18670279   18670279   18670279   18670279   18670279   18670279   18670279 \n\n\n\n\nPart 3\nA function to compute log means an variances for every feature in an assay is defined below, so that the same workflow can be applied both to untreated and treated samples.\n\n# Define function to compute feature-wise log means and vars\nfind_log_stats &lt;- function(assay) {\n  \n  # Compute row means and vars\n  gene_means &lt;- rowMeans(assay)\n  gene_vars &lt;- rowVars(assay)\n\n  # Take log of means and vars with pseudocount\n  gene_log_means &lt;- log(gene_means + 1)\n  gene_log_vars &lt;- log(gene_vars + 1)\n\n  # Combine data into a data.frame\n  df &lt;- data.frame(Var = gene_log_vars, Mean = gene_log_means)\n  return(df)\n}\n\nThe log statistics of the genes from the untreated samples are computed.\n\n# Subset data to untreated samples\ncontrol_cts &lt;- norm_cts[ , grep(\"^untreated\", colnames(norm_cts))]\n# Find log means and vars for genes in control samples\ncontrol_stats &lt;- find_log_stats(control_cts)\n\nThe Poisson distribution fits the data relatively well for lower numbers of reads, but it creates bias for higher numbers of reads where the variance becomes larger than the mean. Such phenomenon is called overdispersion.\n\n# Visualise fit of Poisson distribution to data\nplot(control_stats$Mean, control_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\nabline(a = 0, b = 1, col = \"red\")\nlegend(\"topleft\", \"Poisson Fit\", lty = 1, col = \"red\")\n\n\n\n\nThe dispersion coefficient of the negative binomial distribution can be determined by fitting the corresponding mean-variance relationship to the data.\n\n# Fit dispersion coefficient of negative binomial distribution to data\nnls_fit &lt;- nls(Var ~ Mean + a * Mean^2, data = control_stats, start = list(a = 0))\nsummary(nls_fit)\n\n\nFormula: Var ~ Mean + a * Mean^2\n\nParameters:\n  Estimate Std. Error t value Pr(&gt;|t|)    \na 0.052201   0.000206   253.3   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.8978 on 14598 degrees of freedom\n\nNumber of iterations to convergence: 1 \nAchieved convergence tolerance: 1.408e-11\n\n\nUnlike the Poisson distribution, the negative binomial distribution fits well the data both for lower and higher numbers of reads.\n\n# Define var-mean relationship of negative binomial distribution\ndisper_coef &lt;- summary(nls_fit)$coefficients[\"a\", \"Estimate\"]\nneg_binom &lt;- function(x) x + disper_coef * x^2\n\n# Visualise fit of negative binomial distribution to data\nplot(control_stats$Mean, control_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\ncurve(neg_binom, col = \"red\", add = TRUE)\nlegend(\"topleft\", \"Negative Binomial Fit\", lty = 1, col = \"red\")\n\n\n\n\nThe same pipeline is applied to the genes from the treated samples.\n\n# Subset data to treated samples\ntreated_cts &lt;- norm_cts[ , grep(\"^treated\", colnames(norm_cts))]\n# Find log means and vars for genes in treated samples\ntreated_stats &lt;- find_log_stats(treated_cts)\n\n\n# Visualise fit of Poisson distribution to data\nplot(control_stats$Mean, treated_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\nabline(a = 0, b = 1, col = \"red\")\nlegend(\"topleft\", \"Poisson Fit\", lty = 1, col = \"red\")\n\n\n\n\n\n# Fit dispersion coefficient of negative binomial distribution to data\nnls_fit &lt;- nls(Var ~ Mean + a * Mean^2, data = treated_stats, start = list(a = 0))\nsummary(nls_fit)\n\n\nFormula: Var ~ Mean + a * Mean^2\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \na 0.0439520  0.0002798   157.1   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.227 on 14598 degrees of freedom\n\nNumber of iterations to convergence: 1 \nAchieved convergence tolerance: 7.173e-11\n\n\n\n# Define var-mean relationship of negative binomial distribution\ndisper_coef &lt;- summary(nls_fit)$coefficients[\"a\", \"Estimate\"]\nneg_binom &lt;- function(x) x + disper_coef * x^2\n\n# Visualise fit of negative binomial distribution to data\nplot(treated_stats$Mean, treated_stats$Var, xlab = \"Log Means\", ylab = \"Log Vars\")\ncurve(neg_binom, col = \"red\", add = TRUE)\nlegend(\"topleft\", \"Negative Binomial Fit\", lty = 1, col = \"red\")\n\n\n\n\nJudging by our results, we can estimate that the different untreated and treated samples in this experiment are biological repeats, because these changes are represented by a greater variability that corresponds to a negative binomial distribution and less to a Poisson distribution, this is due to the variability that exists between different animals/tissues. As we can see, our distribution also better fits a negative binomial distribution.\n\n\nPart 4\n\nlog_cts &lt;- log(norm_cts + 1)\n\n\nplot(log_cts[ , \"untreated1\"], log_cts[ , \"treated1\"])\ngrid()\n\n\n\n\n\n# Identify gene that is expressed more in treated samples\ncontrol_cond &lt;- control_stats$Mean &gt; 8.5 & control_stats$Mean &lt; 9.5\ntreated_cond &lt;- treated_stats$Mean &gt; 10 & treated_stats$Mean &lt; 11\n\ngene1 &lt;- rownames(norm_cts)[control_cond & treated_cond]\ngene1\n\n[1] \"FBgn0033367\"\n\n\n\n# Identify gene that is expressed more in untreated samples\ncontrol_cond &lt;- control_stats$Mean &gt; 7 & control_stats$Mean &lt; 8\ntreated_cond &lt;- treated_stats$Mean &gt; 4 & treated_stats$Mean &lt; 5\n\ngene2 &lt;- rownames(norm_cts)[control_cond & treated_cond]\ngene2\n\n[1] \"FBgn0039155\"\n\n\nThe expression of FBgn0039155 shows consistent differences between the control and treated conditions.\n\nplot(log_cts[gene2, ], ylab = \"Log Expression\")\ntitle(gene2)\n\n\n\n\nOur data fit the basic assumptions of DEseq, as it based on negative binomial distribution.\n\nlibrary(DESeq2)\n\n\ndds &lt;- DESeqDataSetFromMatrix(countData = cts,\n                              colData = coldata,\n                              design = ~ condition)\n\ndds &lt;- DESeq(dds)\nres &lt;- results(dds)\n\nres\n\nlog2 fold change (MLE): condition untreated vs treated \nWald test p-value: condition untreated vs treated \nDataFrame with 14599 rows and 6 columns\n               baseMean log2FoldChange     lfcSE        stat    pvalue\n              &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt; &lt;numeric&gt;\nFBgn0000003    0.171569    -1.02604541  3.805503 -0.26962147 0.7874515\nFBgn0000008   95.144079    -0.00215142  0.223884 -0.00960955 0.9923328\nFBgn0000014    1.056572     0.49673557  2.160264  0.22994204 0.8181368\nFBgn0000015    0.846723     1.88276170  2.106432  0.89381546 0.3714206\nFBgn0000017 4352.592899     0.24002523  0.126024  1.90459450 0.0568328\n...                 ...            ...       ...         ...       ...\nFBgn0261571 8.73437e-02     -0.9002942  3.810165  -0.2362875  0.813210\nFBgn0261572 6.19714e+00      0.9591315  0.777017   1.2343759  0.217063\nFBgn0261573 2.24098e+03     -0.0126158  0.112701  -0.1119412  0.910870\nFBgn0261574 4.85774e+03     -0.0152569  0.193148  -0.0789905  0.937040\nFBgn0261575 1.06836e+01     -0.1635594  0.938909  -0.1742016  0.861707\n                 padj\n            &lt;numeric&gt;\nFBgn0000003        NA\nFBgn0000008  0.996927\nFBgn0000014        NA\nFBgn0000015        NA\nFBgn0000017  0.282361\n...               ...\nFBgn0261571        NA\nFBgn0261572        NA\nFBgn0261573  0.982035\nFBgn0261574  0.988143\nFBgn0261575  0.967912\n\n\nCuriously, FBgn0039155 was designated as the most differentially expressed gene by DESeq2 (effect size: 4.62, p-value: 4.07^{-161}), whereas FBgn0033367 did not appear among the top 10 genes but showed statistical significance (effect size: -1.45, p-value: 10^{-9}).\n\nsorted_res &lt;- res[order(res$padj), c(\"log2FoldChange\", \"padj\")]\nhead(sorted_res, 10)\n\nlog2 fold change (MLE): condition untreated vs treated \n \nDataFrame with 10 rows and 2 columns\n            log2FoldChange         padj\n                 &lt;numeric&gt;    &lt;numeric&gt;\nFBgn0039155        4.61901 4.06607e-161\nFBgn0025111       -2.89986 6.38334e-112\nFBgn0029167        2.19700 3.69146e-110\nFBgn0003360        3.17967 1.98854e-105\nFBgn0035085        2.56041  2.14348e-74\nFBgn0039827        4.16252  1.74302e-68\nFBgn0034736        3.51144  4.59386e-57\nFBgn0029896        2.44502  3.03284e-55\nFBgn0000071       -2.67958  8.79175e-46\nFBgn0051092       -2.32771  1.09010e-36\n\n\n\n\nPart 5\nThe circadian RNA-Seq data from Zebrafish is imported and processed into a matrix with unique rownames.\n\ncirc_df &lt;- read.csv(\"data/CircadianRNAseq.csv\")\nrownames(circ_df) &lt;- make.unique(circ_df$GeneSymbol)\ncirc_df[ , c(\"RefSeqID\", \"GeneSymbol\")] &lt;- NULL\ncirc_mat &lt;- as.matrix(circ_df)\n\nThe last five rows (or genes) of the assay are printed below. From the colnames, it can be deduced that samples were collected from 11 PM until 7 PM for two consecutive days, with a time interval of 4 hours.\n\ntail(circ_mat, 5)\n\n              A_11PM     A_3AM     A_7AM    A_11AM     A_3PM     A_7PM\nzgc:136896 255.99900 209.97600 125.42200 143.07200 112.50300 101.81700\nLCP1         5.72658   6.62624   6.62286   9.62324   5.98339   5.37718\nRab3gap1.1  11.32120  14.44910  15.91110  11.89190  13.33890  12.65970\nACTR3       50.64750  56.36470  66.65160  85.98560  54.14030  59.21070\nUBXN4       13.65380  15.55590  23.63540  18.67810  18.75290  16.04330\n              B_11PM     B_3AM     B_7AM   B_11AM    B_3PM    B_7PM\nzgc:136896 201.12300 118.10400 255.72500 89.71120 92.12400 86.27090\nLCP1         3.90986   9.07169   6.51965  6.85435  5.85492  4.42235\nRab3gap1.1  10.15590  16.13480  13.85730 15.99760 15.21870 16.85700\nACTR3       53.61420  58.49680  51.49100 46.21930 50.31010 45.71560\nUBXN4       13.86520  20.21520  15.92240 19.05500 19.76430 19.02300\n\n\nThe expression of the per1a gene shows a rather consistent periodicity of 24 hours over the two days of sampling. Such observation agrees with the literature, as per1a is one of the genes responsible for the circadian rhythm of insects as well as mammals, where it is mostly expressed in the area of the brain known as suprachiasmatic nucleus (SPN).\n\nplot(circ_mat[\"per1a\", ], ylab = \"Norm Expression\", type = \"b\", xaxt = \"n\")\naxis(1, at = 1:12, labels = colnames(circ_mat)) \n\n\n\n\n\npowers &lt;- fft(circ_mat[\"per1a\", ])\npowers &lt;- as.numeric(powers * Conj(powers))[2:(1 + length(powers) / 2)]\nnorm_powers &lt;- powers / sum(powers)\n\n\nt &lt;- 4\nmin_freq &lt;- 1 / (ncol(circ_mat) * t)\nmax_freq &lt;- 1 / (2 * t)\n\nfreq_range &lt;- seq(from = min_freq, to = max_freq, by = min_freq)\n\n\nplot(freq_range, norm_powers, xlab = \"Frequency in 1/h\", ylab = \"Norm Power\")\n\n\n\n\n\ncompute_powers &lt;- function(time_series) {\n  \n  powers &lt;- fft(time_series)\n  powers &lt;- as.numeric(powers * Conj(powers))[2:(1 + length(powers) / 2)]\n  norm_powers &lt;- powers / sum(powers)\n  \n  return(norm_powers)\n}\n\n\npower_mat &lt;- t(apply(circ_mat, 1, compute_powers))\nsorted_powers &lt;- sort(power_mat[ , 2], decreasing = TRUE)\nhead(sorted_powers, 10)\n\n   atxn1b       fus    nr1d2b     rdh1l  ankrd10a    phyhd1 arntl1b.1    ARNTL2 \n0.9658877 0.9575730 0.9518555 0.9505309 0.9502425 0.9459556 0.9420237 0.9276018 \n     Ldhd     aclya \n0.9251018 0.9218165 \n\n\n\nsum(is.na(sorted_powers))\n\n[1] 0\n\n\n\n\nPart 6"
  }
]